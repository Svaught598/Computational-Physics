{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Last Homework\n",
    "### Steven Vaught\n",
    "#### Problems 10.8, 10.9, 10.11, 10.12\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Problem 10.8\n",
    "Calculate a value for the integral\n",
    "\n",
    "$$\n",
    "I = \\int_0^1\\frac{x^{-1/2}}{e^x + 1}dx,\n",
    "$$\n",
    "\n",
    "using the importance sampling formula, Eq. 10.42, with $w(x)=x^{-1/2}$, as follows.\n",
    "\n",
    "#### Part A\n",
    "show that the probability distribution $p(x)$ from which the sample points should be drawn is given by:\n",
    "\n",
    "$$\n",
    "p(x) = \\frac{1}{2\\sqrt{x}}\n",
    "$$\n",
    "\n",
    "and derive a transformation for generating random numbers between zero and one from this distribution\n",
    "\n",
    "#### Part B\n",
    "Using your forumula, sample N = 1,000,000 random points and hence evaluate the integral. You should get a value close to around 0.84."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Part A Derivation:\n",
    "we know that the probability is given by:\n",
    "\n",
    "$$\n",
    "p(x) = \\frac{w(x)}{\\int_a^bw(x)dx}\n",
    "$$\n",
    "\n",
    "substituting what we are given, we get\n",
    "\n",
    "$$\n",
    "p(x) = \\frac{x^{-1/2}}{\\int_0^1x^{-1/2}dx}\n",
    "$$\n",
    "\n",
    "Carrying out the integration in the denominator:\n",
    "\n",
    "$$\n",
    "\\int_0^1x^{-1/2}dx = {2x^{1/2}}\\Biggr\\rvert_1^0 = 2\n",
    "$$\n",
    "\n",
    "Then the expression becomes $p(x) = \\frac{1}{2}x^{-1/2}$, or more simply:\n",
    "\n",
    "$$\n",
    "p(x) = \\frac{1}{2\\sqrt{x}}\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Integral is approx. ~0.83899\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Problem 10.8\n",
    "\n",
    "Integration with Importance Sampling\n",
    "\"\"\"\n",
    "import numpy as np\n",
    "\n",
    "N = 1000000\n",
    "f = lambda x: 1/(np.exp(x) + 1)\n",
    "I = sum(f(np.random.random(N)**2))/N*2\n",
    "print(f\"Integral is approx. ~{I:0.5f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "It seems like it either goes to 400 or -400 depending on the\n",
      "initial conditions of the grid. I assume that an intial net positive spin yields 400\n",
      "while an initial net negative magnetization yields -400. Either the spins all point\n",
      "up by the end, or they all point down. QED.\n",
      "\n",
      "Couldn't get animation to work, I included the code anyway.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Problem 10.9\n",
    "\n",
    "The Ising Model\n",
    "\"\"\"\n",
    "import numpy as np\n",
    "import numpy.random as rn\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.animation as animation\n",
    "\n",
    "\n",
    "\n",
    "\"\"\" Part A +++++++++++++++++++++++\"\"\"\n",
    "\n",
    "def calc_energy(s):\n",
    "    s1 = s[:-1,:]*s[1:,:]\n",
    "    s2 = s[:,:-1]*s[:,1:]\n",
    "    return -J*(np.sum(s1) + np.sum(s2))\n",
    "\n",
    "\"\"\" Part B & C ++++++++++++++++++\"\"\"\n",
    "\n",
    "# Constant Declaration\n",
    "#rn.seed(1)\n",
    "N = 20\n",
    "J = 1\n",
    "T = 1\n",
    "kb = 1\n",
    "beta = 1\n",
    "steps = 1000000\n",
    "\n",
    "# Initialization\n",
    "s = rn.choice([1, -1], size = (N,N), p = (0.5, 0.5))\n",
    "sum_list = []\n",
    "E1 = calc_energy(s)\n",
    "M = sum(s)\n",
    "\n",
    "# Loop over number of iterations\n",
    "for k in range(steps):\n",
    "    \n",
    "    # Random indices\n",
    "    i, j = rn.randint(N), rn.randint(N)\n",
    "    s[i,j] *= -1\n",
    "    \n",
    "    # get new energy & dE from spin flip\n",
    "    E2 = calc_energy(s)\n",
    "    dE = E2 - E1\n",
    "    \n",
    "    \n",
    "    \n",
    "    # if we gain energy from transition ...\n",
    "    if dE > 0:\n",
    "        # if probability is met, we use this transition\n",
    "        if rn.random() < np.exp(-beta * dE):\n",
    "            E1 = E2\n",
    "            M = np.sum(s)\n",
    "        # if probability is not met, we negate it\n",
    "        else: \n",
    "            s[i,j] *= -1\n",
    "    \n",
    "    \n",
    "    \n",
    "    # if we gain negative energy from transition...\n",
    "    else:\n",
    "        # we use this transition\n",
    "        E1 = E2\n",
    "        M = np.sum(s)\n",
    "        \n",
    "\n",
    "    sum_list.append(M)\n",
    "    \n",
    "# Plotting the stuff\n",
    "plt.plot(sum_list)\n",
    "plt.title(\"Total Magnetization\")\n",
    "plt.xlabel(\"Iterations\")\n",
    "plt.ylabel(\"Magnetization\")\n",
    "plt.show()\n",
    "\n",
    "\"\"\" Part D & E ++++++++++++++++++++++++++++\"\"\"\n",
    "\n",
    "\n",
    "print(\n",
    "\"\"\"\n",
    "It seems like it either goes to 400 or -400 depending on the\n",
    "initial conditions of the grid. I assume that an intial net positive spin yields 400\n",
    "while an initial net negative magnetization yields -400. Either the spins all point\n",
    "up by the end, or they all point down. QED.\n",
    "\n",
    "Couldn't get animation to work, I included the code anyway.\n",
    "\"\"\")\n",
    "\n",
    "\n",
    "\n",
    "# Main function\n",
    "def iterate(s):\n",
    "    E1 = calc_energy(s)\n",
    "    for k in range(steps):\n",
    "        i, j = rn.randint(N), rn.randint(N)\n",
    "        s[i,j] *= -1\n",
    "        E2 = calc_energy(s)\n",
    "        dE = E2 - E1\n",
    "        if dE > 0:\n",
    "            if rn.random() < np.exp(-beta * dE):\n",
    "                E1 = E2\n",
    "            else: \n",
    "                s[i,j] *= -1\n",
    "        else:\n",
    "            E1 = E2\n",
    "        yield s\n",
    "\n",
    "# Animation Initialization\n",
    "fig = plt.figure()\n",
    "ax = plt.axes()\n",
    "frame = ax.imshow(s)\n",
    "\n",
    "# Addding frames\n",
    "frame_list = []\n",
    "for p in iterate(s):\n",
    "    frame = ax.plot(p, \"b\")\n",
    "    frame_list.append(frame)\n",
    "\n",
    "# Showing animation\n",
    "anim = animation.ArtistAnimation(fig, frame_list, interval = 5, blit = True)\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Problem 10.11 - The Dimer Covering Problem\n",
    "A well studied problem in condensed matter physics is the dimer covering problem in which dimers, meaning polymers with only two **MOLECULES**, land on the surface of a solid, falling in the spaces between the atoms on the surface and forming a grid like this:\n",
    "\n",
    "$$\n",
    "Pretend_there_is_a_picture_here\n",
    "$$\n",
    "\n",
    "blah blah blah rules and stuff\n",
    "\n",
    "#### Part A\n",
    "Write a program that solves the problem using simulated energy annealing on a 50X50 grid.\n",
    "\n",
    "#### Part B\n",
    "Try exponential cooling with different time constants\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Problem 10.11\n",
    "\n",
    "The Dimer Covering Problem\n",
    "\"\"\"\n",
    "import numpy as np\n",
    "import numpy.random as rn\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.animation as animation\n",
    "\n",
    "\n",
    "# Initialization\n",
    "N = 50\n",
    "n_dimers = 0\n",
    "Tmax = 1.0\n",
    "Tmin = 1e-3\n",
    "tau = 1e4\n",
    "lattice = np.zeros((50, 50), int)\n",
    "\n",
    "# Main Loop\n",
    "def iterate(lattice):\n",
    "\n",
    "    n_dimers = 0\n",
    "    Tmax = 10.0\n",
    "    Tmin = 1e-3\n",
    "    tau = 1e4\n",
    "    t = 0\n",
    "    T = Tmax\n",
    "\n",
    "    while T > Tmin:\n",
    "\n",
    "        # First Coords. of potential Dimer\n",
    "        x1, y1 = rn.randint(N, size = 2)\n",
    "\n",
    "        # Second Coords. of potential Dimer\n",
    "        ran = rn.random()\n",
    "        x2, y2 = x1, y1\n",
    "        if ran < 0.25:\n",
    "            x2 += 1\n",
    "        elif ran < 0.50:\n",
    "            x2 -= 1\n",
    "        elif ran < 0.75:\n",
    "            y2 += 1\n",
    "        elif ran < 1:\n",
    "            y2 -= 1\n",
    "\n",
    "\n",
    "\n",
    "        # if empty replace with Dimer\n",
    "        try:\n",
    "            if lattice[x1, y1] == 0 and lattice[x2, y2] == 0:\n",
    "                lattice[x1, y1] = lattice[x2, y2] = 1\n",
    "                n_dimers += 1\n",
    "\n",
    "            # if Dimer, replace with empty (based on probability p)\n",
    "            if lattice[x1, y1] == 1 and lattice[x2, y2] == 1:\n",
    "                if rn.random() < np.exp(-t/tau):\n",
    "                    lattice[x1, y1] = lattice[x2, y2] = 0\n",
    "                    n_dimers -= 1\n",
    "\n",
    "        except IndexError:\n",
    "            continue\n",
    "\n",
    "        # Cooling\n",
    "        t += 1\n",
    "        T = Tmax*np.exp(-t/tau)\n",
    "        \n",
    "        # yield grid for animation\n",
    "        yield lattice\n",
    "    \n",
    "\n",
    "# Animation Initialization\n",
    "fig = plt.figure()\n",
    "ax = plt.axes()\n",
    "\n",
    "# Addding frames\n",
    "frame_list = []\n",
    "i = 0\n",
    "for cells in iterate(lattice):\n",
    "    if i%100 ==0:\n",
    "        frame = ax.imshow(cells, cmap = \"seismic\", animated = True)\n",
    "        frame_list.append([frame])\n",
    "\n",
    "# Showing animation\n",
    "anim = animation.ArtistAnimation(\n",
    "    fig, \n",
    "    frame_list, \n",
    "    interval = 5, \n",
    "    blit = True,\n",
    "    repeat_delay = 1000\n",
    ")\n",
    "plt.show()\n",
    "\n",
    "\n",
    "coverage = 100*n_dimers/(N*N)\n",
    "print(\"Starting...\")\n",
    "print(f'Coverage Percentage is ~{coverage}')\n",
    "print(f'Number of Dimers is {n_dimers}')\n",
    "print('Couldn\"t get animation to work')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
